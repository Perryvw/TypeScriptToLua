import * as ts from "typescript";

import { TSHelper as tsEx } from "./TSHelper";
import { ForHelper } from "./ForHelper";

import * as path from "path";

export class TranspileError extends Error {
    node: ts.Node;
    constructor(message: string, node: ts.Node) {
        super(message);
        this.node = node;
    }
}

export enum Target {
    Lua53 = "5.3",
    LuaJIT = "JIT"
}

export class LuaTranspiler {
    public static AvailableLuaTargets = [Target.LuaJIT, Target.Lua53];

    // Transpile a source file
    static transpileSourceFile(node: ts.SourceFile, checker: ts.TypeChecker, options: ts.CompilerOptions): string {
        let transpiler = new LuaTranspiler(checker, options, node);

        const header = options.addHeader ? "--=======================================================================================\n"
            + "-- Generated by TypescriptToLua transpiler https://github.com/Perryvw/TypescriptToLua \n"
            + "-- Date: " + new Date().toDateString() + "\n"
            + "--=======================================================================================\n"
            : "";
        let result = header;
        if (!options.dontRequireLualib) {
            // require helper functions
            result += `require("typescript_lualib")\n`;
        }
        if (transpiler.isModule) {
            // Shadow exports if it already exists
            result += "local exports = exports or {}\n";
        }
        result += transpiler.transpileBlock(node);
        if (transpiler.isModule) {
            result += "return exports\n"
        }
        return result;
    }

    indent: string;
    checker: ts.TypeChecker;
    options: ts.CompilerOptions;
    genVarCounter: number;
    transpilingSwitch: boolean;
    namespace: string[];
    importCount: number;
    isModule: boolean;
    sourceFile: ts.SourceFile;

    constructor(checker: ts.TypeChecker, options: ts.CompilerOptions, sourceFile: ts.SourceFile) {
        this.indent = "";
        this.checker = checker;
        this.options = options;
        this.genVarCounter = 0;
        this.transpilingSwitch = false;
        this.namespace = [];
        this.importCount = 0;
        this.sourceFile = sourceFile;
        this.isModule = tsEx.isFileModule(sourceFile);
    }

    pushIndent(): void {
        this.indent = this.indent + "    ";
    }

    popIndent(): void {
        this.indent = this.indent.slice(4);
    }

    definitionName(name: string | ts.__String): string {
        return this.namespace.concat(<string>name).join(".");
    }

    accessPrefix(node?: ts.Node): string {
        return node && this.isModule ?
            "local " : ""
    }

    makeExport(name: string | ts.__String, node: ts.Node, dummy?: boolean): string {
        let result: string = "";
        if (node && node.modifiers && (ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Export)) {
            if (dummy) {
                result = this.indent + `exports.${this.definitionName(name)} = {}\n`;
            } else {
                result = this.indent + `exports.${this.definitionName(name)} = ${name}\n`;
            }
        }
        if (this.namespace.length !== 0 && !ts.isModuleDeclaration(node)) {
            if (dummy) {
                result += this.indent + `${this.definitionName(name)} = {}\n`;
            } else {
                result += this.indent + `${this.definitionName(name)} = ${name}\n`;
            }
        }
        return result;
    }

    getImportPath(relativePath: string) {
        // Calculate absolute path to import
        let absolutePathToImport = path.resolve(path.dirname(this.sourceFile.fileName), relativePath);
        if (this.options.rootDir) {
            // Calculate path realtive to project root and replace path.sep with dots (lua doesn't know paths)
            return `"${absolutePathToImport.replace(this.options.rootDir, "").replace(new RegExp("\\\\|\/", "g"), ".").slice(1)}"`;
        }
        return `"${relativePath.replace(new RegExp("\\\\|\/", "g"), ".")}"`;
    }

    // Transpile a block
    transpileBlock(node: ts.Node): string {
        let result = "";

        if (ts.isBlock(node)) {
            node.statements.forEach(statement => {
                result += this.transpileNode(statement);
            });
        } else {
            node.forEachChild(child => {
                result += this.transpileNode(child);
            });
        }

        return result;
    }

    // Transpile a node of unknown kind.
    transpileNode(node: ts.Node): string {
        //Ignore declarations
        if (tsEx.getChildrenOfType(node, child => child.kind == ts.SyntaxKind.DeclareKeyword).length > 0) return "";

        switch (node.kind) {
            case ts.SyntaxKind.ImportDeclaration:
                return this.transpileImport(<ts.ImportDeclaration>node);
            case ts.SyntaxKind.ClassDeclaration:
                return this.transpileClass(<ts.ClassDeclaration>node);
            case ts.SyntaxKind.ModuleDeclaration:
                return this.transpileNamespace(<ts.ModuleDeclaration>node);
            case ts.SyntaxKind.ModuleBlock:
                return this.transpileBlock(<ts.Block>node);
            case ts.SyntaxKind.EnumDeclaration:
                return this.transpileEnum(<ts.EnumDeclaration>node);
            case ts.SyntaxKind.FunctionDeclaration:
                return this.transpileFunctionDeclaration(<ts.FunctionDeclaration>node);
            case ts.SyntaxKind.VariableStatement:
                return this.indent + this.transpileVariableStatement(<ts.VariableStatement>node) + "\n";
            case ts.SyntaxKind.ExpressionStatement:
                return this.indent + this.transpileExpression(<ts.Expression>tsEx.getChildren(node)[0]) + "\n";
            case ts.SyntaxKind.ReturnStatement:
                return this.indent + this.transpileReturn(<ts.ReturnStatement>node) + "\n";
            case ts.SyntaxKind.IfStatement:
                return this.transpileIf(<ts.IfStatement>node);
            case ts.SyntaxKind.WhileStatement:
                return this.transpileWhile(<ts.WhileStatement>node);
            case ts.SyntaxKind.ForStatement:
                return this.transpileFor(<ts.ForStatement>node);
            case ts.SyntaxKind.ForOfStatement:
                return this.transpileForOf(<ts.ForOfStatement>node);
            case ts.SyntaxKind.ForInStatement:
                return this.transpileForIn(<ts.ForInStatement>node);
            case ts.SyntaxKind.SwitchStatement:
                return this.transpileSwitch(<ts.SwitchStatement>node);
            case ts.SyntaxKind.BreakStatement:
                return this.transpileBreak();
            case ts.SyntaxKind.TryStatement:
                return this.transpileTry(<ts.TryStatement>node);
            case ts.SyntaxKind.ThrowStatement:
                return this.transpileThrow(<ts.ThrowStatement>node);
            case ts.SyntaxKind.ContinueStatement:
                // Disallow continue
                throw new TranspileError("Continue is not supported in Lua", node);
            case ts.SyntaxKind.TypeAliasDeclaration:
            case ts.SyntaxKind.InterfaceDeclaration:
            case ts.SyntaxKind.EndOfFileToken:
                // Ignore these
                return "";
            default:
                return this.indent + this.transpileExpression(node) + "\n";
        }
    }

    transpileImport(node: ts.ImportDeclaration): string {
        const importPath = this.transpileExpression(node.moduleSpecifier);
        let importPathWithoutQuotes = importPath.replace(new RegExp("\"", "g"), "");

        if (!node.importClause || !node.importClause.namedBindings) {
            throw new TranspileError("Default Imports are not supported, please use named imports instead!", node);
        }

        const imports = node.importClause.namedBindings;

        if (ts.isNamedImports(imports)) {
            const fileImportTable = path.basename(importPathWithoutQuotes) + this.importCount;
            let result = `local ${fileImportTable} = require(${this.getImportPath(importPathWithoutQuotes)})\n`;
            this.importCount++;
            imports.elements.forEach(element => {
                if (element.propertyName) {
                    result += `local ${element.name.escapedText} = ${fileImportTable}.${element.propertyName.escapedText}\n`;
                } else {
                    result += `local ${element.name.escapedText} = ${fileImportTable}.${element.name.escapedText}\n`;
                }
            });
            return result;
        } else if (ts.isNamespaceImport(imports)) {
            return `local ${imports.name.escapedText} = require(${this.getImportPath(importPathWithoutQuotes)})\n`;
        } else {
            throw new TranspileError("Unsupported import type.", node);
        }
    }

    transpileNamespace(node: ts.ModuleDeclaration): string {
        // If phantom namespace just transpile the body as normal
        if (tsEx.isPhantom(this.checker.getTypeAtLocation(node), this.checker)) return this.transpileNode(node.body);

        const defName = this.definitionName(node.name.text);
        let result = this.indent + this.accessPrefix(node) + `${node.name.text} = ${node.name.text} or {}\n`;
        if (this.namespace.length > 0) {
            result += this.indent + `${defName} = ${node.name.text} or {}\n`;
        }
        result += this.makeExport(defName, node);
        // Create closure
        result += this.indent + "do\n";
        this.pushIndent();
        this.namespace.push(node.name.text);
        result += this.transpileNode(node.body);
        this.namespace.pop();
        this.popIndent();
        result += this.indent + "end\n";
        return result;
    }

    transpileEnum(node: ts.EnumDeclaration): string {
        let val = 0;
        let result = "";

        const type = this.checker.getTypeAtLocation(node);
        const membersOnly = tsEx.isCompileMembersOnlyEnum(type, this.checker);

        if (!membersOnly) {
            const name = node.name.escapedText;
            result += this.indent + this.accessPrefix(node) + `${name}={}\n`;
            result += this.makeExport(name, node);
        }

        node.members.forEach(member => {
            if (member.initializer) {
                if (ts.isNumericLiteral(member.initializer)) {
                    val = parseInt(member.initializer.text);
                } else {
                    throw new TranspileError("Only numeric initializers allowed for enums.", node);
                }
            }

            if (membersOnly) {
                const defName = this.definitionName((<ts.Identifier>member.name).escapedText);
                result += this.indent + `${defName}=${val}\n`;
            } else {
                const defName = this.definitionName(`${node.name.escapedText}.${(<ts.Identifier>member.name).escapedText}`);
                result += this.indent + `${defName}=${val}\n`;
            }

            val++;
        });
        return result;
    }

    transpileBreak(): string {
        if (this.transpilingSwitch) {
            return '';
        } else {
            return this.indent + "break\n";
        }
    }

    transpileIf(node: ts.IfStatement): string {
        const condition = this.transpileExpression(node.expression);

        let result = this.indent + `if ${condition} then\n`;
        this.pushIndent();
        result += this.transpileStatement(node.thenStatement);
        this.popIndent();

        if (node.elseStatement) {
            result += this.indent + "else\n";
            this.pushIndent();
            result += this.transpileStatement(node.elseStatement);
            this.popIndent();
        }

        return result + this.indent + "end\n";
    }

    transpileWhile(node: ts.WhileStatement): string {
        const condition = this.transpileExpression(node.expression);

        let result = this.indent + `while ${condition} do\n`;
        this.pushIndent();
        result += this.transpileStatement(node.statement);
        this.popIndent();
        return result + this.indent + "end\n";
    }

    transpileFor(node: ts.ForStatement): string {
        // Get iterator variable
        const variable = (<ts.VariableDeclarationList>node.initializer).declarations[0];
        const identifier = <ts.Identifier>variable.name;

        // Populate three components of lua numeric for loop:
        let start = this.transpileExpression(variable.initializer);
        let end = ForHelper.GetForEnd(node.condition, this);
        let step = ForHelper.GetForStep(node.incrementor, this);

        // Add header
        let result = this.indent + `for ${identifier.escapedText}=${start},${end},${step} do\n`;

        // Add body
        this.pushIndent();
        result += this.transpileStatement(node.statement);
        this.popIndent();

        return result + this.indent + "end\n";
    }

    transpileForOf(node: ts.ForOfStatement): string {
        // Get variable identifier
        const variable = (<ts.VariableDeclarationList>node.initializer).declarations[0];
        const identifier = <ts.Identifier>variable.name;

        // Transpile expression
        const expression = this.transpileExpression(node.expression);

        // Use ipairs for array types, pairs otherwise
        const isArray = tsEx.isArrayType(this.checker.getTypeAtLocation(node.expression));
        const pairs = isArray ? "ipairs" : "pairs";

        // Make header
        let result = this.indent + `for _, ${identifier.escapedText} in ${pairs}(${expression}) do\n`;

        // For body
        this.pushIndent();
        result += this.transpileStatement(node.statement);
        this.popIndent();

        return result + this.indent + "end\n";
    }

    transpileForIn(node: ts.ForInStatement): string {
        // Get variable identifier
        const variable = <ts.VariableDeclaration>(<ts.VariableDeclarationList>node.initializer).declarations[0];
        const identifier = <ts.Identifier>variable.name;

        // Transpile expression
        const expression = this.transpileExpression(node.expression);

        if (tsEx.isArrayType(this.checker.getTypeAtLocation(node.expression))) {
            throw new TranspileError("Iterating over arrays with 'for in' is not allowed.", node);
        }

        // Make header
        let result = this.indent + `for ${identifier.escapedText}, _ in pairs(${expression}) do\n`;

        // For body
        this.pushIndent();
        result += this.transpileStatement(node.statement);
        this.popIndent();

        return result + this.indent + "end\n";
    }

    transpileStatement(node: ts.Statement): string {
        if (ts.isBlock(node)) {
            return this.transpileBlock(node);
        } else {
            return this.transpileNode(node);
        }
    }

    transpileSwitch(node: ts.SwitchStatement): string {
        const expression = this.transpileExpression(node.expression, true);
        const clauses = node.caseBlock.clauses;

        let result = this.indent + "-------Switch statement start-------\n";

        let jumpTableName = "____switch" + this.genVarCounter;
        this.genVarCounter++;

        result += this.indent + `local ${jumpTableName} = {}\n`;

        // If statement to go to right entry label
        clauses.forEach((clause, index) => {
            if (ts.isCaseClause(clause)) {
                result += this.indent + `-- case:\n`;
                result += this.indent + `${jumpTableName}[${this.transpileExpression(clause.expression, true)}] = function()\n`;
            }
            if (ts.isDefaultClause(clause)) {
                result += this.indent + `-- default:\n`;
                result += this.indent + `${jumpTableName}["____default${this.genVarCounter}"] = function()\n`;
            }
            this.pushIndent();

            this.transpilingSwitch = true;
            clause.statements.forEach(statement => {
                result += this.transpileNode(statement);
            });
            this.transpilingSwitch = false;

            let i = index + 1;
            if (i < clauses.length && !tsEx.containsStatement(clause.statements, ts.SyntaxKind.BreakStatement)) {
                let nextClause = clauses[i];
                while (i < clauses.length
                    && ts.isCaseClause(nextClause)
                    && nextClause.statements.length === 0
                ) {
                    i++;
                    nextClause = clauses[i];
                }

                if (i !== index && nextClause) {
                    if (ts.isCaseClause(nextClause)) {
                        result += this.indent + `${jumpTableName}[${this.transpileExpression(nextClause.expression, true)}]()\n`;
                    } else {
                        result += this.indent + `${jumpTableName}["____default${this.genVarCounter}"]()\n`;
                    }
                }
            } else {
                result += this.indent + `-- break;\n`;
            }

            this.popIndent();

            result += this.indent + `end\n`;
        });
        result += this.indent + `if ${jumpTableName}[${expression}] then ${jumpTableName}[${expression}]()\n`;
        result += this.indent + `elseif ${jumpTableName}["____default${this.genVarCounter}"] then ${jumpTableName}["____default${this.genVarCounter}"]() end\n`;
        result += this.indent + "--------Switch statement end--------\n";

        //Increment counter for next switch statement
        this.genVarCounter += clauses.length;
        return result;
    }

    transpileTry(node: ts.TryStatement): string {
        let tryFunc = "function()\n";
        this.pushIndent();
        tryFunc += this.transpileBlock(node.tryBlock);
        this.popIndent();
        tryFunc += "end";
        let catchFunc = "function(e)\nend";
        if (node.catchClause) {
            let variableName = (<ts.Identifier>node.catchClause.variableDeclaration.name).escapedText;
            catchFunc = this.indent + `function(${variableName})\n`;
            this.pushIndent();
            catchFunc += this.transpileBlock(node.catchClause.block);
            this.popIndent();
            catchFunc += "end";
        }
        let result = this.indent + `xpcall(${tryFunc},\n${catchFunc})\n`;
        if (node.finallyBlock) {
            result += this.transpileBlock(node.finallyBlock);
        }
        return result;
    }

    transpileThrow(node: ts.ThrowStatement): string {
        if (ts.isStringLiteral(node.expression)) {
            return `error("${node.expression.text}")`;
        } else {
            throw new TranspileError("Unsupported throw expression, only string literals are supported", node.expression)
        }
    }

    transpileReturn(node: ts.ReturnStatement): string {
        if (node.expression) {
            // If parent function is a TupleReturn function and return expression is an array literal, leave out brackets.
            var declaration = tsEx.findFirstNodeAbove(node, ts.isFunctionDeclaration);
            if (declaration && tsEx.isTupleReturnFunction(this.checker.getTypeAtLocation(declaration), this.checker)
                && ts.isArrayLiteralExpression(node.expression)) {
                return "return " + node.expression.elements.map(elem => this.transpileExpression(elem)).join(",");
            }

            // Otherwise just do a normal return
            return "return " + this.transpileExpression(node.expression);
        } else {
            return "return"
        }
    }

    transpileExpression(node: ts.Node, brackets?: boolean): string {
        switch (node.kind) {
            case ts.SyntaxKind.BinaryExpression:
                // Add brackets to preserve ordering
                return this.transpileBinaryExpression(<ts.BinaryExpression>node, brackets);
            case ts.SyntaxKind.ConditionalExpression:
                // Add brackets to preserve ordering
                return this.transpileConditionalExpression(<ts.ConditionalExpression>node, brackets);
            case ts.SyntaxKind.CallExpression:
                return this.transpileCallExpression(<ts.CallExpression>node);
            case ts.SyntaxKind.PropertyAccessExpression:
                return this.transpilePropertyAccessExpression(<ts.PropertyAccessExpression>node);
            case ts.SyntaxKind.ElementAccessExpression:
                return this.transpileElementAccessExpression(<ts.ElementAccessExpression>node);
            case ts.SyntaxKind.Identifier:
                // For identifiers simply return their name
                return (<ts.Identifier>node).text;
            case ts.SyntaxKind.StringLiteral:
                const text = (<ts.StringLiteral>node).text;
                return `"${text}"`;
            case ts.SyntaxKind.TemplateExpression:
                return this.transpileTemplateExpression(<ts.TemplateExpression>node);
            case ts.SyntaxKind.NumericLiteral:
                return (<ts.NumericLiteral>node).text;
            case ts.SyntaxKind.TrueKeyword:
                return "true";
            case ts.SyntaxKind.FalseKeyword:
                return "false";
            case ts.SyntaxKind.NullKeyword:
                return "nil";
            case ts.SyntaxKind.ThisKeyword:
                return "self";
            case ts.SyntaxKind.PostfixUnaryExpression:
                return this.transpilePostfixUnaryExpression(<ts.PostfixUnaryExpression>node);
            case ts.SyntaxKind.PrefixUnaryExpression:
                return this.transpilePrefixUnaryExpression(<ts.PrefixUnaryExpression>node);
            case ts.SyntaxKind.ArrayLiteralExpression:
                return this.transpileArrayLiteral(<ts.ArrayLiteralExpression>node);
            case ts.SyntaxKind.ObjectLiteralExpression:
                return this.transpileObjectLiteral(<ts.ObjectLiteralExpression>node);
            case ts.SyntaxKind.DeleteExpression:
                return this.transpileExpression((<ts.DeleteExpression>node).expression) + "=nil";
            case ts.SyntaxKind.FunctionExpression:
            case ts.SyntaxKind.ArrowFunction:
                return this.transpileArrowFunction(<ts.ArrowFunction>node);
            case ts.SyntaxKind.NewExpression:
                return this.transpileNewExpression(<ts.NewExpression>node);
            case ts.SyntaxKind.ComputedPropertyName:
                return "[" + this.transpileExpression((<ts.ComputedPropertyName>node).expression) + "]";
            case ts.SyntaxKind.ParenthesizedExpression:
                return "(" + this.transpileExpression((<ts.ParenthesizedExpression>node).expression) + ")";
            case ts.SyntaxKind.SuperKeyword:
                return "self.__base";
            case ts.SyntaxKind.TypeAssertionExpression:
                // Simply ignore the type assertion
                return this.transpileExpression((<ts.TypeAssertion>node).expression);
            case ts.SyntaxKind.AsExpression:
                // Also ignore as casts
                return this.transpileExpression((<ts.AsExpression>node).expression);
            default:
                throw new TranspileError("Unsupported expression kind: " + tsEx.enumName(node.kind, ts.SyntaxKind), node);
        }
    }

    transpileBinaryExpression(node: ts.BinaryExpression, brackets?: boolean): string {
        // Transpile operands
        const lhs = this.transpileExpression(node.left, true);
        const rhs = this.transpileExpression(node.right, true);

        // Rewrite some non-existant binary operators
        let result = "";

        // Transpile Bitops
        if (this.options.luaTarget === Target.LuaJIT) {
            switch (node.operatorToken.kind) {
                case ts.SyntaxKind.AmpersandToken:
                    result = `bit.band(${lhs},${rhs})`;
                    break;
                case ts.SyntaxKind.AmpersandEqualsToken:
                    result = `${lhs}=bit.band(${lhs},${rhs})`;
                    break;
                case ts.SyntaxKind.BarToken:
                    result = `bit.bor(${lhs},${rhs})`;
                    break;
                case ts.SyntaxKind.BarEqualsToken:
                    result = `${lhs}=bit.bor(${lhs},${rhs})`;
                    break;
                case ts.SyntaxKind.LessThanLessThanToken:
                    result = `bit.lshift(${lhs},${rhs})`;
                    break;
                case ts.SyntaxKind.LessThanLessThanEqualsToken:
                    result = `${lhs}=bit.lshift(${lhs},${rhs})`;
                    break;
                case ts.SyntaxKind.GreaterThanGreaterThanToken:
                    result = `bit.arshift(${lhs},${rhs})`;
                    break;
                case ts.SyntaxKind.GreaterThanGreaterThanEqualsToken:
                    result = `${lhs}=bit.arshift(${lhs},${rhs})`;
                    break;
                case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
                    result = `bit.rshift(${lhs},${rhs})`;
                    break;
                case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:
                    result = `${lhs}=bit.rshift(${lhs},${rhs})`;
                    break;
            }
        } else {
            switch (node.operatorToken.kind) {
                case ts.SyntaxKind.AmpersandToken:
                    result = `${lhs}&${rhs}`;
                    break;
                case ts.SyntaxKind.AmpersandEqualsToken:
                    result = `${lhs}=${lhs}&${rhs}`;
                    break;
                case ts.SyntaxKind.BarToken:
                    result = `${lhs}|${rhs}`;
                    break;
                case ts.SyntaxKind.BarEqualsToken:
                    result = `${lhs}=${lhs}|${rhs}`;
                    break;
                case ts.SyntaxKind.LessThanLessThanToken:
                    result = `${lhs}<<${rhs}`;
                    break;
                case ts.SyntaxKind.LessThanLessThanEqualsToken:
                    result = `${lhs}=${lhs}<<${rhs}`;
                    break;
                case ts.SyntaxKind.GreaterThanGreaterThanToken:
                    result = `${lhs}>>${rhs}`;
                    break;
                case ts.SyntaxKind.GreaterThanGreaterThanEqualsToken:
                    result = `${lhs}=${lhs}>>${rhs}`;
                    break;
                case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
                    result = `${lhs}>>>${rhs}`;
                    break;
                case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:
                    result = `${lhs}=${lhs}>>>${rhs}`;
                    break;
            }
        }

        // Transpile operators
        if (result === "") {
            switch (node.operatorToken.kind) {
                case ts.SyntaxKind.PlusEqualsToken:
                    result = `${lhs}=${lhs}+${rhs}`;
                    break;
                case ts.SyntaxKind.MinusEqualsToken:
                    result = `${lhs}=${lhs}-${rhs}`;
                    break;
                case ts.SyntaxKind.AsteriskEqualsToken:
                    result = `${lhs}=${lhs}*${rhs}`;
                    break;
                case ts.SyntaxKind.SlashEqualsToken:
                    result = `${lhs}=${lhs}/${rhs}`;
                    break;
                case ts.SyntaxKind.AmpersandAmpersandToken:
                    result = `${lhs} and ${rhs}`;
                    break;
                case ts.SyntaxKind.BarBarToken:
                    result = `${lhs} or ${rhs}`;
                    break;
                case ts.SyntaxKind.PlusToken:
                    // Replace string + with ..
                    const typeLeft = this.checker.getTypeAtLocation(node.left);
                    const typeRight = this.checker.getTypeAtLocation(node.right);
                    if ((typeLeft.flags & ts.TypeFlags.String) || ts.isStringLiteral(node.left)
                        ||  (typeRight.flags & ts.TypeFlags.String) || ts.isStringLiteral(node.right)) {
                        return lhs + " .. " + rhs;
                    }
                    result = `${lhs}+${rhs}`;
                    break;
                case ts.SyntaxKind.MinusToken:
                    result = `${lhs}-${rhs}`;
                    break;
                case ts.SyntaxKind.AsteriskToken:
                    result = `${lhs}*${rhs}`;
                    break;
                case ts.SyntaxKind.SlashToken:
                    result = `${lhs}/${rhs}`;
                    break;
                case ts.SyntaxKind.PercentToken:
                    result = `${lhs}%${rhs}`;
                    break;
                case ts.SyntaxKind.GreaterThanToken:
                    result = `${lhs}>${rhs}`;
                    break;
                case ts.SyntaxKind.GreaterThanEqualsToken:
                    result = `${lhs}>=${rhs}`;
                    break;
                case ts.SyntaxKind.LessThanToken:
                    result = `${lhs}<${rhs}`;
                    break;
                case ts.SyntaxKind.LessThanEqualsToken:
                    result = `${lhs}<=${rhs}`;
                    break;
                case ts.SyntaxKind.EqualsToken:
                    result = `${lhs}=${rhs}`;
                    break;
                case ts.SyntaxKind.EqualsEqualsToken:
                case ts.SyntaxKind.EqualsEqualsEqualsToken:
                    result = `${lhs}==${rhs}`;
                    break;
                case ts.SyntaxKind.ExclamationEqualsToken:
                case ts.SyntaxKind.ExclamationEqualsEqualsToken:
                    result = `${lhs}~=${rhs}`;
                    break;
                case ts.SyntaxKind.InKeyword:
                    result = `${rhs}[${lhs}]~=nil`;
                    break;
                default:
                    throw new TranspileError("Unsupported binary operator kind: " + ts.tokenToString(node.operatorToken.kind), node);
            }
        }

        // Optionally put brackets around result
        if (brackets) {
            return `(${result})`;
        } else {
            return result;
        }
    }

    transpileTemplateExpression(node: ts.TemplateExpression) {
        let parts = [`"${node.head.text}"`];
        node.templateSpans.forEach(span => {
            const expr = this.transpileExpression(span.expression, true);
            if (ts.isTemplateTail(span.literal)) {
                parts.push(`tostring(${expr}).."${span.literal.text}"`);
            } else {
                parts.push(`tostring(${expr}).."${span.literal.text}"`);
            }
        });
        return parts.join("..");
    }

    transpileConditionalExpression(node: ts.ConditionalExpression, brackets?: boolean): string {
        let condition = this.transpileExpression(node.condition);
        let val1 = this.transpileExpression(node.whenTrue);
        let val2 = this.transpileExpression(node.whenFalse);

        return `TS_ITE(${condition},function() return ${val1} end,function() return ${val2} end)`;
    }

    transpilePostfixUnaryExpression(node: ts.PostfixUnaryExpression): string {
        const operand = this.transpileExpression(node.operand, true);
        switch (node.operator) {
            case ts.SyntaxKind.PlusPlusToken:
                return `${operand}=${operand}+1`;
            case ts.SyntaxKind.MinusMinusToken:
                return `${operand}=${operand}-1`;
            default:
                throw new TranspileError("Unsupported unary postfix: " + tsEx.enumName(node.kind, ts.SyntaxKind), node);
        }
    }

    transpilePrefixUnaryExpression(node: ts.PrefixUnaryExpression): string {
        const operand = this.transpileExpression(node.operand, true);
        switch (node.operator) {
            case ts.SyntaxKind.PlusPlusToken:
                return `${operand}=${operand}+1`;
            case ts.SyntaxKind.MinusMinusToken:
                return `${operand}=${operand}-1`;
            case ts.SyntaxKind.ExclamationToken:
                return `not ${operand}`;
            case ts.SyntaxKind.MinusToken:
                return `-${operand}`;
            default:
                throw new TranspileError("Unsupported unary prefix: " + tsEx.enumName(node.kind, ts.SyntaxKind), node);
        }
    }

    transpileNewExpression(node: ts.NewExpression): string {
        const name = this.transpileExpression(node.expression);
        const params = this.transpileArguments(node.arguments, ts.createTrue());

        return `${name}.new(${params})`;
    }

    transpileCallExpression(node: ts.CallExpression): string {
        // Check for calls on primitives to override
        if (ts.isPropertyAccessExpression(node.expression)) {
            const expType = this.checker.getTypeAtLocation(node.expression.expression);

            if (expType.symbol && expType.symbol.escapedName == "Math") {
                const params = this.transpileArguments(node.arguments);
                return this.transpileMathExpression(node.expression.name) + `(${params})`;
            }

            if (this.transpileExpression((node.expression as ts.PropertyAccessExpression).expression) === "String") {
                const params = this.transpileArguments(node.arguments);
                return this.transpileStringExpression(node.expression.name) + `(${params})`;
            }

            switch (expType.flags) {
                case ts.TypeFlags.String:
                case ts.TypeFlags.StringLiteral:
                    return this.transpileStringCallExpression(node);
                case ts.TypeFlags.Object:
                    if (tsEx.isArrayType(expType))
                        return this.transpileArrayCallExpression(node);
            }

            if (expType.symbol && (expType.symbol.flags & ts.SymbolFlags.Namespace)) {
                // Don't replace . with : for namespaces
                const callPath = this.transpileExpression(node.expression);
                const params = this.transpileArguments(node.arguments);
                return `${callPath}(${params})`;
            } else {
                 // Replace last . with : here
                const callPath = `${this.transpileExpression(node.expression.expression)}:${node.expression.name.escapedText}`;
                const params = this.transpileArguments(node.arguments);
                return `${callPath}(${params})`;
            }
        }

        // Handle super calls properly
        if (node.expression.kind == ts.SyntaxKind.SuperKeyword) {
            let callPath = this.transpileExpression(node.expression);
            const params = this.transpileArguments(node.arguments, <ts.Expression>ts.createNode(ts.SyntaxKind.ThisKeyword));
            return `self.__base.constructor(${params})`;
        }

        let callPath = this.transpileExpression(node.expression);
        const params = this.transpileArguments(node.arguments);
        return `${callPath}(${params})`;
    }

    transpileStringCallExpression(node: ts.CallExpression): string {
        const expression = <ts.PropertyAccessExpression>node.expression;
        const params = this.transpileArguments(node.arguments);
        const caller = this.transpileExpression(expression.expression);
        switch (expression.name.escapedText) {
            case "replace":
                return `string.gsub(${caller},${params})`;
            case "indexOf":
                if (node.arguments.length == 1) {
                    return `(string.find(${caller},${params},1,true) or 0)-1`;
                } else {
                    return `(string.find(${caller},${params}+1,true) or 0)-1`;
                }
            case "substring":
                if (node.arguments.length == 1) {
                    return `string.sub(${caller},${params}+1)`;
                } else {
                    const arg1 = this.transpileExpression(node.arguments[0]);
                    const arg2 = this.transpileExpression(node.arguments[1]);
                    return `string.sub(${caller},${arg1}+1,${arg2})`;
                }
            case "toLowerCase":
                return `string.lower(${caller})`;
            case "toUpperCase":
                return `string.upper(${caller})`;
            case "split":
                return `TS_split(${caller},${params})`;
            case "charAt":
                return `string.sub(${caller},${params}+1,${params}+1)`;
            default:
                throw new TranspileError("Unsupported string function: " + expression.name.escapedText, node);
        }
    }

    // Transpile a String._ property
    transpileStringExpression(identifier: ts.Identifier): string {
        const translation = {
            fromCharCode: "string.char",
            fromCodePoint: "utf8.char"
        };

        if (<string>identifier.escapedText === "fromCodePoint" && this.options.luaTarget !== Target.Lua53) {
            throw new TranspileError(`Unsupported string property ${identifier.escapedText} is only supported for lua 5.3.`, identifier);
        }

        if (translation[<string>identifier.escapedText]) {
            return `${translation[<string>identifier.escapedText]}`;
        } else {
            throw new TranspileError(`Unsupported string property ${identifier.escapedText}.`, identifier);
        }
    }

    transpileArrayCallExpression(node: ts.CallExpression): string {
        const expression = <ts.PropertyAccessExpression>node.expression;
        const params = this.transpileArguments(node.arguments);
        const caller = this.transpileExpression(expression.expression);
        switch (expression.name.escapedText) {
            case "push":
                return `TS_push(${caller}, ${params})`;
            case "forEach":
                return `TS_forEach(${caller}, ${params})`;
            case "indexOf":
                return `TS_indexOf(${caller}, ${params})`;
            case "map":
                return `TS_map(${caller}, ${params})`;
            case "filter":
                return `TS_filter(${caller}, ${params})`;
            case "some":
                return `TS_some(${caller}, ${params})`;
            case "every":
                return `TS_every(${caller}, ${params})`;
            case "slice":
                return `TS_slice(${caller}, ${params})`;
            case "splice":
                return `TS_splice(${caller}, ${params})`;
            case "join":
                if (node.arguments.length === 0) {
                    // if seperator is omitted default seperator is ","
                    return `table.concat(${caller}, ",")`;
                } else {
                    return `table.concat(${caller}, ${params})`;
                }
            default:
                throw new TranspileError("Unsupported array function: " + expression.name.escapedText, node);
        }
    }

    transpileArguments(params: ts.NodeArray<ts.Expression>, context?: ts.Expression): string {
        const parameters: string[] = [];

        // Add context as first param if present
        if (context) {
            parameters.push(this.transpileExpression(context));
        }

        params.forEach(param => {
            parameters.push(this.transpileExpression(param));
        });

        return parameters.join(",");
    }

    transpilePropertyAccessExpression(node: ts.PropertyAccessExpression): string {
        const property = node.name.text;

        // Check for primitive types to override
        const type = this.checker.getTypeAtLocation(node.expression);
        switch (type.flags) {
            case ts.TypeFlags.String:
            case ts.TypeFlags.StringLiteral:
                return this.transpileStringProperty(node);
            case ts.TypeFlags.Object:
                if (tsEx.isArrayType(type))
                    return this.transpileArrayProperty(node);
        }

        // Do not output path for member only enums
        if (tsEx.isCompileMembersOnlyEnum(type, this.checker)) {
            return property;
        }

        // Catch math expressions
        if (ts.isIdentifier(node.expression) && node.expression.escapedText == "Math") {
            return this.transpileMathExpression(node.name);
        }

        let path = this.transpileExpression(node.expression);
        return `${path}.${property}`;
    }

    // Transpile a Math._ property
    transpileMathExpression(identifier: ts.Identifier): string {
        const translation = {
            abs: "abs",
            acos: "acos",
            asin: "asin",
            atan: "atan",
            ceil: "ceil",
            cos: "cos",
            exp: "exp",
            floor: "floor",
            log: "log",
            max: "max",
            min: "min",
            PI: "pi",
            pow: "pow",
            random: "random",
            round: "round",
            sin: "sin",
            sqrt: "sqrt",
            tan: "tan"
        };

        if (translation[<string>identifier.escapedText]) {
            return `math.${translation[<string>identifier.escapedText]}`;
        } else {
            throw new TranspileError(`Unsupported math property ${identifier.escapedText}.`, identifier);
        }
    }

    // Transpile access of string properties, only supported properties are allowed
    transpileStringProperty(node: ts.PropertyAccessExpression): string {
        const property = node.name;
        switch (property.escapedText) {
            case "length":
                return "#" + this.transpileExpression(node.expression);
            default:
                throw new TranspileError("Unsupported string property: " + property.escapedText, node);
        }
    }

    // Transpile access of array properties, only supported properties are allowed
    transpileArrayProperty(node: ts.PropertyAccessExpression): string {
        const property = node.name;
        switch (property.escapedText) {
            case "length":
                return "#" + this.transpileExpression(node.expression);
            default:
                throw new TranspileError("Unsupported array property: " + property.escapedText, node);
        }
    }

    transpileElementAccessExpression(node: ts.ElementAccessExpression): string {
        const element = this.transpileExpression(node.expression);
        const index = this.transpileExpression(node.argumentExpression);

        const type = this.checker.getTypeAtLocation(node.expression);
        if (tsEx.isArrayType(type) || tsEx.isTupleType(type)) {
            return `${element}[${index}+1]`;
        } else if (tsEx.isStringType(type)) {
            return `string.sub(${element},${index}+1,${index}+1)`;
        } else {
            return `${element}[${index}]`;
        }
    }

    // Transpile a variable statement
    transpileVariableStatement(node: ts.VariableStatement): string {
        let result = "";

        node.declarationList.declarations.forEach(declaration => {
            result += this.transpileVariableDeclaration(<ts.VariableDeclaration>declaration);
            result += this.makeExport((<ts.Identifier>declaration.name).escapedText, node);
        });

        return result;
    }

    transpileVariableDeclaration(node: ts.VariableDeclaration): string {
        if (ts.isIdentifier(node.name)) {
            // Find variable identifier
            const identifier = node.name;
            if (node.initializer) {
                const value = this.transpileExpression(node.initializer);
                return `local ${identifier.escapedText} = ${value}\n`;
            } else {
                return `local ${identifier.escapedText} = nil\n`;
            }
        } else if (ts.isArrayBindingPattern(node.name)) {
            // Destructuring type
            const value = this.transpileExpression(node.initializer);

            // Disallow ellipsis destruction
            if (node.name.elements.some(elem => !ts.isBindingElement(elem) || elem.dotDotDotToken !== undefined)) {
                throw new TranspileError(`Ellipsis destruction is not allowed.`, node);
            }

            const vars = node.name.elements.map(element => (<ts.Identifier>(<ts.BindingElement>element).name).escapedText).join(",");

            // Don't unpack TupleReturn decorated functions
            if (ts.isCallExpression(node.initializer)
                && tsEx.isTupleReturnFunction(this.checker.getTypeAtLocation(node.initializer.expression), this.checker)) {
                return `local ${vars}=${value}`;
            } else {
                return `local ${vars}=unpack(${value})`;
            }
        } else {
            throw new TranspileError("Unsupported variable declaration type " + tsEx.enumName(node.name.kind, ts.SyntaxKind), node);
        }
    }

    transpileFunctionDeclaration(node: ts.FunctionDeclaration): string {
        let result = "";
        const identifier = node.name;
        const methodName = identifier.escapedText;
        const parameters = node.parameters;
        const body = node.body;

        // Build parameter string
        let paramNames: string[] = [];
        parameters.forEach(param => {
            paramNames.push(<string>(<ts.Identifier>param.name).escapedText);
        });

        // Build function header
        result += this.indent + this.accessPrefix(node) + `function ${methodName}(${paramNames.join(",")})\n`;

        this.pushIndent();
        result += this.transpileBlock(body);
        this.popIndent();

        // Close function block
        result += this.indent + "end\n";

        result += this.makeExport(methodName, node);

        return result;
    }

    transpileMethodDeclaration(node: ts.MethodDeclaration, path: string): string {
        let result = "";
        const identifier = <ts.Identifier>node.name;
        const methodName = identifier.escapedText;
        const parameters = node.parameters;
        const body = node.body;

        // Build parameter string
        let paramNames: string[] = ["self"];
        parameters.forEach(param => {
            paramNames.push(<string>(<ts.Identifier>param.name).escapedText);
        });

        // Build function header
        result += this.indent + `function ${path}${methodName}(${paramNames.join(",")})\n`;

        this.pushIndent();
        result += this.transpileBlock(body);
        this.popIndent();

        // Close function block
        result += this.indent + "end\n";

        return result;
    }

    // Transpile a class declaration
    transpileClass(node: ts.ClassDeclaration): string {
        // Find extends class, ignore implements
        let extendsType;
        let noClassOr = false;
        if (node.heritageClauses) node.heritageClauses.forEach(clause => {
            if (clause.token == ts.SyntaxKind.ExtendsKeyword) {
                const superType = this.checker.getTypeAtLocation(clause.types[0]);
                // Ignore purely abstract types (decorated with /** @PureAbstract */)
                if (!tsEx.isPureAbstractClass(superType, this.checker)) {
                    extendsType = clause.types[0];
                }
                noClassOr = tsEx.hasCustomDecorator(superType, this.checker, "!NoClassOr");
            }
        });

        let className = <string>node.name.escapedText;
        let result = "";

        // Skip header if this is an extension class
        const isExtension = tsEx.isExtensionClass(this.checker.getTypeAtLocation(node), this.checker);
        if (!isExtension) {
            // Write class declaration
            const classOr = noClassOr ? "" : `${className} or `;
            if (!extendsType) {
                result += this.indent + this.accessPrefix(node) + `${className} = ${classOr}{}\n`;
                result += this.makeExport(className, node);
            } else {
                const baseName = (<ts.Identifier>extendsType.expression).escapedText;
                result += this.indent + this.accessPrefix(node) + `${className} = ${classOr}${baseName}.new()\n`;
                result += this.makeExport(className, node);
            }
            result += this.indent + `${className}.__index = ${className}\n`;
            if (extendsType) {
                const baseName = (<ts.Identifier>extendsType.expression).escapedText;
                result += this.indent + `${className}.__base = ${baseName}\n`;
            }
            result += this.indent + `function ${className}.new(construct, ...)\n`;
            result += this.indent + `    local instance = setmetatable({}, ${className})\n`;
            result += this.indent + `    if construct and ${className}.constructor then ${className}.constructor(instance, ...) end\n`;
            result += this.indent + `    return instance\n`;
            result += this.indent + `end\n`;
        } else {
            // export empty table
            result += this.makeExport(className, node, true);
            // Overwrite the original className with the class we are overriding for extensions
            if (extendsType) {
                className = <string>(<ts.Identifier>extendsType.expression).escapedText;
            }
        }

        // Get all properties with value
        const properties = node.members.filter(ts.isPropertyDeclaration)
            .filter(_ => _.initializer);

        // Divide properties into static and non-static
        const isStatic = _ => _.modifiers && _.modifiers.some(_ => _.kind == ts.SyntaxKind.StaticKeyword);
        const staticFields = properties.filter(isStatic);
        const instanceFields = properties.filter(_ => !isStatic(_));

        // Add static declarations
        for (const field of staticFields) {
            const fieldName = (<ts.Identifier>field.name).escapedText;
            let value = this.transpileExpression(field.initializer);
            result += this.indent + `${className}.${fieldName} = ${value}\n`;
        }

        // Try to find constructor
        const constructor = node.members.filter(ts.isConstructorDeclaration)[0];
        if (constructor) {
            // Add constructor plus initialisation of instance fields
            result += this.transpileConstructor(constructor, className, instanceFields);
        } else {
            // No constructor, make one to set all instance fields if there are any
            if (instanceFields.length > 0) {
                // Create empty constructor and add instance fields
                result += this.transpileConstructor(ts.createConstructor([], [], [], ts.createBlock([], true)), className, instanceFields);
            }
        }

        // Transpile methods
        node.members.filter(ts.isMethodDeclaration).forEach(method => {
            result += this.transpileMethodDeclaration(method, `${className}.`);
        });

        return result;
    }

    transpileConstructor(node: ts.ConstructorDeclaration, className: string, instanceFields: ts.PropertyDeclaration[]): string {
        const extraInstanceFields = [];

        let parameters = ["self"];
        node.parameters.forEach(param => {
            // If param has decorators, add extra instance field
            if (param.modifiers != undefined) extraInstanceFields.push(<string>(<ts.Identifier>param.name).escapedText);
            // Add to parameter list
            parameters.push(<string>(<ts.Identifier>param.name).escapedText);
        });

        let result = this.indent + `function ${className}.constructor(${parameters.join(",")})\n`;

        // Add in instance field declarations
        for (const f of extraInstanceFields) {
            result += this.indent + `    self.${f} = ${f}\n`;
        }

        for (const f of instanceFields) {
            // Get identifier
            const fieldIdentifier = <ts.Identifier>f.name;
            const fieldName = fieldIdentifier.escapedText;

            let value = this.transpileExpression(f.initializer);

            result += this.indent + `    self.${fieldName} = ${value}\n`;
        }

        // Transpile constructor body
        this.pushIndent();
        result += this.transpileBlock(node.body);
        this.popIndent();

        return result + this.indent + "end\n";
    }

    transpileArrayLiteral(node: ts.ArrayLiteralExpression): string {
        let values: string[] = [];

        node.elements.forEach(child => {
            values.push(this.transpileExpression(child));
        });

        return "{" + values.join(",") + "}";
    }

    transpileObjectLiteral(node: ts.ObjectLiteralExpression): string {
        let properties: string[] = [];
        // Add all property assignments
        node.properties.forEach(assignment => {
            const [key, value] = tsEx.getChildren(assignment);
            if (ts.isIdentifier(key)) {
                properties.push(`${key.escapedText}=` + this.transpileExpression(value));
            } else if (ts.isComputedPropertyName(key)) {
                const index = this.transpileExpression(key);
                properties.push(`${index}=` + this.transpileExpression(value));
            } else {
                const index = this.transpileExpression(<ts.Expression>key);
                properties.push(`[${index}]=` + this.transpileExpression(value));
            }
        });

        return "{" + properties.join(",") + "}";
    }

    transpileFunctionExpression(node: ts.FunctionExpression): string {
        // Build parameter string
        let paramNames: string[] = [];
        node.parameters.forEach(param => {
            paramNames.push(<string>(<ts.Identifier>param.name).escapedText);
        });

        let result = `function(${paramNames.join(",")})\n`;
        this.pushIndent();
        result += this.transpileBlock(node.body);
        this.popIndent();
        return result + this.indent + "end\n";
    }

    transpileArrowFunction(node: ts.ArrowFunction): string {
        // Build parameter string
        let paramNames: string[] = [];
        node.parameters.forEach(param => {
            paramNames.push(<string>(<ts.Identifier>param.name).escapedText);
        });

        if (ts.isBlock(node.body)) {
            let result = `function(${paramNames.join(",")})\n`;
            this.pushIndent();
            result += this.transpileBlock(node.body);
            this.popIndent();
            return result + this.indent + "end\n";
        } else {
            return `function(${paramNames.join(",")}) return ` + this.transpileExpression(node.body) + " end";
        }
    }
}
